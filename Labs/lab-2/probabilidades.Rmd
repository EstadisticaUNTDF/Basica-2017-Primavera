---
title: "Laboratorio 2 - Probabilidades y Simulación"
output:
  html_document:
    css: ../lab.css
    highlight: pygments
    theme: cerulean
  pdf_document: default
bibliography: probabilidades.bib
nocite: | 
  @Estadisticas2001, @Estadisticas2002, @Estadisticas2003, @Estadisticas2004,
  @Estadisticas2005, @Estadisticas2006, @Estadisticas2007, @Estadisticas2008,
  @Estadisticas2009, @Estadisticas2010, @Estadisticas2011, @Estadisticas2012,
  @Estadisticas2013, @Estadisticas2014, @Estadisticas2015
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(eval = FALSE)
library(dplyr)
library(ggplot2)
```

<div id="boxedtext">
**Una nota sobre el espacio de trabajo:** 

Before we get started with the lab, let's take a moment
to review our R Markdown workflow and remind ourselves about workspaces in R.
The workspaces of the console and the workspaces of your R Markdown document are
not the same. Therefore, if you define a variable only in the Console and then try to
use that variable in your R Markdown document, you'll get an error. This might
seem frustrating at first, but it is actually a feature that helps you in the long
run. In order to ensure that your report is fully reproducible, everything that
is used in the report must be defined in the report, and not somewhere else.

It is your responsibility, and an important learning goal of this course, that you 
master the skills for creating fully reproducible data analysis reports. Below are 
some tips for achieving this goal:

- Always work in your R Markdown document, and not in the Console.
- Knit early, and often, always checking that the resulting document contains 
everything you expected it to contain.
</div> 

* * *

<div id="template">
**Your reproducible lab report:** Before you get started, download the R Markdown 
template for this lab. Remember all of your code and answers go in this document:
```{r load-template, eval = FALSE}
download.file("http://stat.duke.edu/courses/Spring16/sta101.001/rmd/lab3.Rmd", destfile = "lab3.Rmd")
```
</div>

## Manos Calientes

Se dice que los jugadores de basquet que anotan varias veces seguidas tienen
las *manos calientes*. Fans y jugadores han creído por mucho tiempo en este 
fenómeno, que refuta la suposición de que cada tiro es independiente del otro.
Sin embargo, un [paper de 1985](http://www.sciencedirect.com/science/article/pii/0010028585900106) de
Gilovich, Vallone, y Tversky recolectó evidencias que contradecian esta 
creencia y mostraron que los tiros sucesivos son sucesos independientes. Este
paper comenzó una controversia que sigue hasta hoy, lo pueden comprobar 
buscando *hot hand basketball*.

No esperamos resolver esta controversia hoy. Sin embargo, en este laboratorio
vamos a aplicar una forma de resolver preguntas como esta. Los objetivos de 
este laboratorio son (1) penser sobre los efectos de los sucesos independientes
y dependientes, (2) aprender a simular rachas de anotaciones en R, y (3) 
comparar las simulaciones con datos reales de forma de determinar si el
fenómeno de manos calientes parece ser real.

## Empezando

Nuestra investigación se va a enfocar en el rendimiento de un jugador: Kobe
Bryant de los Angeles Lakers. Su rendimiento en las finales de la NBA de 2009
contra Orlando Magic le ganó el título de *Most Valuable Player* (Jugador más
valioso) y muchos espectadores comentaron que parecia tener las manos calientes.
Carguemos los archivos que necesitaremos en este laboratorio.


```{r load-data}
load(url("https://stat.duke.edu/~mc301/data/hot_hand.RData"))
```

Deberías ver tu pestaña de espacion de trabajo (*Environment*)  hay dos
nuevos objetos: `kobe_basket` y `calc_streak`:

- `kobe_basket`: un data frame de 133 observaciones y 6 variables, donde cada
fila muestra un tiro hecho por Kobe Bryant. La variable `shot` en este dataset
indica si el tiro fue un éxito (`H`) o un fracaso (`M`)
- `calc_streak`: una función a medida que vamos a usar para calcular la longitud
de las rachas (más adelante).

Solo viendo a los datos de éxitos y fracasos puede ser difícil juzgar si Kobe
tenía una mano caliente o no. Una forma de investigar esto es considerando la 
creencia de que los tiradores con manos calientes tienden a tener rachas de 
anotaciones. Para este laboratorio, vamos a definir la longitud de un racha
de encestadas como *el número de anotaciones consecutivas hasta que un fallo 
ocurre*.

Por ejemplo, en el juego 1 Kobe tuvo la siguiente secuencia de éxitos 
y fracasos de sus nueve tiros en el primer cuarto:

\[ \textrm{H M | M | H H M | M | M | M} \]

Pueden verificarlo viendo las primeras 8 filas de los datos en el vizualizador
de datos.

Dentro de esos nueve intentos de encestar, hay seis rachcas, que están 
separadas por "|" arriba. Sus longitudes son uno, cero, dos, cero, cero, cero 
(en orden de ocurrencia).

1. ¿Qué significa una racha de longitud 1?, i.e ¿Cuántos éxitos y fracasos hay
una racha de 1? ¿Cuántos en un racha de longitud 0?

Contar la longitud de las rachas manualmente para los 133 tiros seria tedioso,
entonces vamos a usar una función a medida `calc_racha` para calcularlas, y
guardar los resultados en un data frame llamado `kobe_racha` como la variable
`longitud`

```{r calc-streak-kobe}
kobe_racha <- calc_racha(kobe_basket$shot)
```

Podemos visualizar la distribución de las longitudes de rachas.
We can then take a look at the distribution of these streak lengths.

```{r plot-streak-kobe}
ggplot(data = kobe_racha, aes(x = longitud)) +
         geom_histogram(binwidth = 1)
```

2.  Describe la distrubución de las rachas de Kobe en las finales de 2009 de la
    NBA ¿Cuál es la longitud típica de la rachas? ¿Cuál fue su racha más
    larga? Asegurate de incluir el gráfico en tu respuesta.


## ¿Comparado con qué?

Hemos mostrado que Kobe tuvo algunas rachas largas ¿Pero son lo suficientemente
largas para apoyar la creencia de que tenía manos calientes? ¿Con las podemos
comparar?

Para responder estas preguntas volvamos a a la idea de *independencia*. Dos 
eventos son independientes si el resultado de uno no afecta el resultado del
otro. Si los tiros que hace un jugador es un evento independiente, haber 
acertado o errado el primer tiro no afectará la probabilidad de que el segundo
tiro sea acertado o errado.

Un tiraror con manos calientes tendrá tiros que no *son* independiente uno de 
otro. Especificamente, si un jugador acierta su primer disparo, el modelo de 
manos calientes dice que tendrá un probabilidad *mayor* de acertar su segundo
disparo.

Supongamos por un momento que el modelo de manos calientes es válido para Kobe.
Durante su carrera, el porcentaje de tiempo que Kobe encesta (i.e. su porcentaje
de tiros) es cerca del 45%, o en notación de probabilidad:


\[ P(\textrm{tiro 1 = E}) = 0.45 \]

Si logra su primer tiro y tiene manos calientes (los tiros *no* son
independientes), entonces la probabilidad de que convierta su segundo tiro 
aumentaría, digamos 60%:
If he makes the first shot and has a hot hand (*not* independent shots), then 
the probability that he makes his second shot would go up to, let's say, 60%,

\[ P(\textrm{tiro 2 = E} \, | \, \textrm{tiro 1 = E}) = 0.60 \]

Como resultado de esta probabilidades aumentadas, espeararíamos que Kobe tubiese
rachas más largas. Comparando esto con la perspectiva escéptica donde Kobe
*no* tiene manos calientes, cada tiro es independiente del anterior. Si 
convierte su primer tiro, la probabilidad de que convierta el segundo todavía
es 0.45

\[ P(\textrm{tiro 2 = E} \, | \, \textrm{tiro 1 = E}) = 0.45 \]

En otras palabras, convertir el primer tiro no hizo nada para afectar la 
probabilidad de convierta el segundo. Si los tiros de Kobe son independientes, 
entonces la probabilidad de encestar cada tiro sería la misma sin importar sus
tiros pasados: 45%

Ahora que hemos descripto la situación en términos de tiros independietes, 
volvamos al meollo de la cuestión: ¿Cómo podemos saber si las rachas de tiros
de Kobe son lo suficientemente largas para indicar que tiene manos calientes? 
Podemos comparar sus rachas con alguien que no tenga manos calientes: un
tirador independiente.

## Simulaciones en R

Aunque no tenemos datos de ningún jugador que sepamos que tenga tiros 
independientes, ese tipo de datos es muy fácil de simular en R. En una 
simulación, podés poner tus reglas a un proceso aleatorio y luego que la 
computadora use números aleatorios para generar una salida que se adhiera a esas
reglas. Como un simple ejemplo, podemos simular el lanzamiento de una moneda:


```{r head-tail}
resultados_moneda <- c("cara", "cruz")
sample(resultados_moneda, size = 1, replace = TRUE)
```

El vector `resultados` puede ser pensado como un sombrero que tiene dos 
papelitos en el: uno dice `cara`y el otro dice `cruz`. La función `sample` 
extrae un papel del sombrero y nos dice si fue cara o cruz.

Ejecuta el segundo comando varias veces. Tal como si lanzaras una moneda, a 
veces obtenes cara y a veces obtenes cruz, pero a la larga, esperamos obtener
un número similar de cada una.

Si quisieramos simular lanzar una moneda equilibrada 100 veces, podriamos 
correr la función 100 veces (¡qué aburrido!), o más sencillo, ajustar el 
argumento `size`, que indica cuantas muestras sacara (el argumento 
`replace = TRUE` indica que debemos devolver el papel al sombrero antes de volver
a sacar). Guarda el vector resultado de lanzar 100 monedas en un nuevo objeto 
llamado `sim_moneda_eq`.

```{r sim-fair-coin}
sim_moneda_eq <- sample(resultados_moneda, size = 100, replace = TRUE)
```

Para ver el resultado de la simulación, tipea el nombre del objeto y luego usa
la función `table` para contar el número de caras y cruces.

```{r table-sim-fair-coin}
sim_moneda_eq
table(sim_moneda_eq)
```

Dado que solo hay dos elementos en `resultados`, la probabilidad de que lanzemos
una moneda y caiga en cara es de 0.5. Digamos que estamos intentando
simular un moneda cargada que sabemos que solo sale cara el 20% de la veces.
Podemos ajustar esto añadiendo un argumento llamado `prob`, que contiene un
vector con las pesos de las probabilidades.

```{r sim-unfair-coin}
sim_moneda_cargada <- sample(resultados_moneda, size = 100, replace = TRUE, 
                          prob = c(0.2, 0.8))
```

`prob=c(0.2, 0.8)` indica que de los dos elementos en el vector `resultados` 
queremos seleccionar el primero, `cara`, con una probabilidad de 0.2, y el 
segundo, `cruz`, con una probabilidad de 0.8. Otra forma de pensarlo es imaginar
un sombrero con 10 papeles, dos de los papeles están marcados como "cara" y ocho
como "cruz". Por lo tanto, en cada extracción, la probabilidad de sacar una 
papel que diga "cara" es de 20% y "cruz" es de 80%


3.  En tu simulación de lanzar una monedad cargada 100 vece ¿Cuántas veces
    apareció cara? Incluye el código para muestrear una moneda cargada en tu
    respuesta. Dado que el archivo de markdown va a correr el código, y generar
    una nueva muestra cada vez que lo *Tejas*, tamibén deberías "configurar una
    semilla" **antes** de muestrear. Lee más sobre configurar una semilla abajo.

<div id="boxedtext">
**Una nota sobre configurar la semilla:** Configurar la semilla causa que R
muestree la misma muestra cada vez que tejas el documento. Esto va a asegurar
que tus resultados no cambien cada vez que tejas, y también va a asegurar que tu
trabajo sea reproducible (al configurar la semilla es posible reproducir los
resultados). Podes configurar la semilla así:

```{r set-seed}
set.seed(9102015)                 # asegurarte de cambiar el número
```

El número de arriba es completamente arbitrario. Si necesitas inspiración, podés
usar tu DNI, cumpleaños, o alguna secuencia completamente aleatoria. Lo 
importante es que uses una semilla solo una vez. Recuerda hacerlo **antes** de
los muestreos en el ejercicio de arriba.
</div>

En un sentido, hemos achicado el tamaño del papelito que dice "cara", haciendo
menos probable que sea extraido y hemos incrementado la probabilidad del papel
que dice "cara", haciendo más probable que sea extraido. Cuando simulamos la 
moneda equilibrada, los dos papelitos tenian el mismo tamaño. Esto sucede por
defecto si no proporcionamos un argumento `prob; todos los elementos en el 
vector `outcomes` tienen la misma probabilidad de ser extraídos.

Si querés aprender más de la función `sample` u otras funciones, recuerda que 
podes revisar su ayuda.

```{r help-sample,tidy = FALSE}
?sample
```

## Simulando el Tirador Independiente

Simular un jugador de báquet que dispara independientemente usa el mismo
mecanismo que usamos para simular el lanzamiento de una moneda. Para simular
un solo tiro de un tirador independente con un porcentaje de tiro de 50% escribe:

```{r sim-basket}
resultados_tiro <- c("E", "F")
sim_baquet <- sample(resultados_tiro, size = 1, replace = TRUE)
```

Para hacer una comparación válida entre Kobe y nuestro tirador independiente
simulado debemos alinear tanto su porcentaje de tiro y el número de tiros
intentados.

4.  ¿Qué necesitamos cambiar en la función `sample` para reflejar un porcentaje
    de tiro de 45%? Haz este ajuste, y luego corre la simulación para muestrear
    133 tiros. Asigna el resultado de la simulación a un nuevo objeto llamado
    `sim_basquet`.

Nota que has nombrado el nuevo vector `sim_basquet`, el mismo nombre que le
dimos al vector anterior reflejando un porcentaje de tiro de 50%. En esta 
situación, R sobreescribe el viejo objeto con el nuevo, así que asegurarte que 
no necesitas información del viejo vector antes de reasignar su nombre.

Con los resultados guardados como `sim_basquet`, tenemos los datos necesarios
para comparar Kobe con nuestro tirador independiente.

Ambos conjuntos de datos representan los resultados de 133 intentos de tiros,
cada uno hecho con un porcentaje de tiro de 45%. Sabemos que nuestros datos
simulados son de un tirador cuyos tiros son independientes. Esto es, sabemos
que nuestro tirador no tiene manos calientes.

* * *

<div class="oyo">

## Por su cuenta

### Comparando Kobe Bryant con un Tirador Independiente

-   Using `calc_streak`, compute the streak lengths of `sim_basket`, and
    save the results in a data frame called `sim_streak`. Note that since the
    `sim_streak` object is just a vector and not a variable in a data frame,
    we don't need to first select it from a data frame like we did earlier
    when we calculated the streak lengths for Kobe's shots.

-   Describe the distribution of streak lengths. What is the typical streak 
    length for this simulated independent shooter with a 45% shooting percentage?
    How long is the player's longest streak of baskets in 133 shots? Make sure
    to include a plot in your answer.

-   If you were to run the simulation of the independent shooter a second time, 
    how would you expect its streak distribution to compare to the distribution 
    from the question above? Exactly the same? Somewhat similar? Totally 
    different? Explain your reasoning.

-   How does Kobe Bryant's distribution of streak lengths compare to the 
    distribution of streak lengths for the simulated shooter? Using this 
    comparison, do you have evidence that the hot hand model fits Kobe's 
    shooting patterns? Explain.

-   What concepts from the textbook are covered in this lab? What concepts, if 
    any, are not covered in the textbook? Have you seen these concepts elsewhere,
    e.g. class, videos, textbook, previous labs, or homework problems? Be
    specific in your answer.

</div>

<div id="license">
This is a product of OpenIntro that is released under a 
[Creative Commons Attribution-ShareAlike 3.0 Unported](http://creativecommons.org/licenses/by-sa/3.0). 
This lab was adapted for OpenIntro by Andrew Bray and Mine &Ccedil;etinkaya-Rundel
from a lab written by Mark Hansen of UCLA Statistics.
</div>

